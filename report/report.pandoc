---
geometry: margin=1in
numbersections: true
title: Applying Crowbar Voltage Glitches to nRF52 and CC253x/4x Microcontrollers
author: Jonathan Rudman 1907314
date: >
  \today\endgraf
  University of Birmingham
abstract: >
  This is an abstract.
  Spoil the ending; say how you haven't managed to glitch the CC2541 with a crowbar glitch on the CPU. TODO.
bibliography: references.bib
csl: ieee.csl
header-includes: >
  \linespread{1.2}
  \usepackage{xcolor}
  \lstset{
      basicstyle=\ttfamily,
      numbers=left,
      numberstyle=\footnotesize,
      numbersep=5pt,
      showspaces=false,
      showstringspaces=false,
      showtabs=false,
      tabsize=2,
      captionpos=b,
      breaklines=true,
      breakatwhitespace=true,
      breakautoindent=true,
      linewidth=\textwidth
  }
---

\tableofcontents

<!-- TODO: Move some of the caption text out to paragraphs and reference the figures with it. -->

# Introduction

<!-- TODO: Write introduction. Use below as a template -->

<!-- Put in mention of code readout protection, implementation attacks and background -->
<!-- The following is ripped from the demonstration speaker notes and needs turning into acceptable language -->

The "crowbar" technique involves momentarily shorting the CPU voltage to ground in order to miscalculate or skip an instruction.

Embedded systems based around microcontrollers are in everything now, from watches to washing machines.
Microcontroller firmware is often protected from being read by the consumer with code readout protection (CRP), usually in the form of disabling debugging access to the microcontroller.
This means that independent security researchers can't easily assess the firmware for security vulnerabilities and consumers of many IoT devices are left with e-waste they can't repurpose when the manufacturer goes bankrupt and can no longer provide them with the service they paid for.

There are many ways that this can be remedied, but I've been researching fault injection methods to bypass the CRP and dump the firmware.
Specifically, using voltage injection.
Why?
Because:

- Legislative solutions are slow, expensive and require many people in order for them to gain traction and, even then, can fail easily. Right to repair, for example, is a movement that's gained more traction over the last year, but it's not a new debate, and I think that highlights the difficulty of this route.
- Fault injection can be a very reliable way (citation?) to put a microcontroller into a debugging state, which allows the full extraction of application firmware.
- Voltage glitching is an inexpensive and quickly repeatable fault injection method when compared to invasive methods such as using laser or UV-C light.

## Related work

@rothHowAppleAirTags2021 has shown how the nRF52832, used in Apple AirTags, can be glitched to skip its CRP check.
Roth also cites earlier work from a blog, @limitedresultsNRF52DebugResurrection2020, which focuses on a similar system-on-a-chip (SoC), the nRF52840, and presents information from the nRF52 family in the context of voltage glitching and CRP.
Replicating Roth's and LimitedResults' work is the first experiment of this project and was used as a framework for learning about many aspects of voltage glitching for the first time before moving onto a novel experiment: applying a similar glitch to the Texas Instruments CC2541.

@vandenherrewegenFillYourBoots2020 describe voltage glitching in conjunction with binary analysis---a grey-box approach---on embedded bootloaders.
Although the nRF52832---the target of this report's first voltage glitch experiment---has a CRP check before the bootloader (which is stored on flash memory), Van Den Herrewegen et al. outline voltage glitches on three different MCUs.
In the aforementioned paper the GIAnT, @oswaldGiantrevBGIAnTFault, is also used for the attacks.
GIAnT is used throughout this report as the primary glitching system for glitching the nRF52832 and CC2541, although the Pico Debug'n'Dump, @rothPicoDebugDump, was also used against the nRF52832 for comparison.

@oflynnFaultInjectionUsing2016 details the application of crowbar circuits in voltage glitching methods.
Similar to O'Flynn's usage of the n-channel MOSFET on the ChipWhisperer, both the Pico Debug'n'Dump and GIAnT boards utilise an n-channel MOSFET---which applies a short to ground in a target circuit---in their implementations of a crowbar circuit.

The exploratory experiments on the CC2541 outlined later in this report (power analysis, glitching anything to find reasonable parameters, etc.) were inspired by a glitch campaign carried out by GitHub user @debug-siliconSiLabsC8051F34xCode2021 against the SiLabs C8051F340.
Much like the Texas Instruments CC2541, the SiLabs C8051F340 is also an 8051-based chip.
Methods outlined by @woutersSusceptibilityTexasInstruments, although applied to Texas Instruments microcontrollers based around ARM Cortex-M CPUs, were also helpful in compiling this report.
Reading both of these works also helped in understanding what often makes a voltage glitch targeting CRP checks possible---neither the similarities between CPUs or manufacturers, but rather the nature of the CRP check itself (which could be done outside the CPU) or the copying of CRP data.

## Success criteria

The success criteria have changed since the project proposal, but settled on the following: 

- Replicate the crowbar attack @rothHowAppleAirTags2021 carried out on an nRF52832 on a development board.
- Add to the knowledge of which chips are vulnerable to crowbar voltage glitch attacks.
  - Answer whether same crowbar technique applied to the nRF52 series by both @rothHowAppleAirTags2021 and @limitedresultsNRF52DebugResurrection2020 could be replicated and applied to another family of microcontrollers, the CC253x/4x series from Texas Instruments.
- Evaluate how it might be made easier and more reliable to carry out crowbar attacks.

Previously, this project's success criteria were focussed on successfully glitching and then dumping the firmware of the nRF52832 and, later, the CC2541.
In contrast, the bullet points above are more learning-oriented, focussing on investigation and the various activities that need to be executed to find a voltage glitch vulnerability, should one exist.

# Replicating a crowbar attack on the nRF52832

The nRF52832 is a member of the nRF52 series from Nordic Semiconductors, a series based around the ARM Cortex-M4 processor and a 2.4GHz transceiver.
This section outlines a successful attempt at replicating the crowbar voltage glitch attack on the nRF52832---initially demonstrated by @rothHowAppleAirTags2021---to fault its CRP check and allow debugging access in the serial bootloader.
Roth showed how the nRF52832 could be glitched in situ on the AirTag PCB and built on the efforts of @limitedresultsNRF52DebugResurrection2020 who used the nRF52840, but the following experiment aims to glitch the nRF52832 on a development board.
It is likely that, due to the similarities in features, processors and memory layouts, a voltage glitch which allows CRP bypass on one member of the nRF52 series is also applicable, with little to no adjustments, to any other member of the nRF52 series of microcontrollers.
These similarities are why LimitedResults' method can also be applied to the nRF52832.

Without a background in electronics and fault injection, the reproduction of Roth's and LimitedResults' experiments proved to be a learning experience.
This process would go on to provide knowledge and practise in preparation for investigating whether similar attacks would be possible on the CC2541.

## Glitch method

The glitch method for nRF52 microcontrollers, outlined by @limitedresultsNRF52DebugResurrection2020 and @rothHowAppleAirTags2021, is to:

1. Power on the microcontroller.
2. Wait until the memory controller starts transferring the user information configuration register values---including APPROTECT, the value of which determines whether the debug access port is protected---to the core. This time period is called the _glitch offset_.
3. Short the CPU power to ground for a time period, the _glitch width_.

<!-- TODO: How is the CRP checked by the glitcher? -->

### Generic setup

Before using a glitch generator such as the Pico Debug'n'Dump or GIAnT, it is important to identify which pins will need to be accessed for the experiment.
The following pins must be identified on the target:

- Power supply and ground connections because the microcontroller needs to be powered and operational while glitching.
- Debug access pins, for dumping firmware and sending other commands to the target.
- A decoupling circuit for the target, if not glitching the power supply voltage.

A general purpose computer is used to configure the glitch parameters on the glitch generator and communicate with the nRF52832 over a debugging interface---in the case of the nRF52832, an ST-LINK V2, connected over USB to the general purpose computer.


### Modifications

A number of wires needed to be attached to the nRF52832 development board for easy connection to other jumper wires.
These wires had to be connected to the following pins on the nRF52832 chip itself:

- VDD: Power supply
- VSS: Ground
- SWDCLK: Serial wire debug clock input, for debugging
- SWDIO: Serial wire debug I/O, for debugging
- DEC1: $0.9V$ digital supply decoupling (CPU voltage regulator)

Identifying which pins these are requires referring to the nRF52832 Product Specification and using a multimeter to find the development board pins they are attached to.
The pins on the nRF52832 development board were too narrow and close together for any of the jumper wires available, so jumper wires were cut and soldered onto them for easier access.

Glitching the CPU voltage regulator decoupling circuit allows an attacker to specifically target the CPU, rather than the full system, which prevents the glitch being "absorbed" by other circuitry.
The decoupling capacitor was also removed from the DEC1, to prevent damping of the glitch and the traces when reading the oscilloscope. <!-- Check accuracy of this -->

## Using Pico Debug'n'Dump

The video demonstrating the nRF52832 glitch, uploaded by @rothHowAppleAirTags2021, introduces the Pico Debug'n'Dump, a device Roth created to make crowbar voltage glitching cheaper and easier.

The glitching application, published by @rothAirtagglitcher2021 on GitHub, was flashed to the Debug'n'Dump by the general purpose computer.
Below is a table of the wiring setup.

| Debug'n'Dump | nRF52832 | ST-LINK | Description                           |
|--------------|----------|---------|---------------------------------------|
| Trig         | VDD      |         | Supplies nRF52832 with 3.3V           |
| Glitch       | DEC1     |         | For shorting the CPU                  |
| GND          | GND      |         | Grounds the nRF52832                  |
|              | SWDIO    | SWDIO   | Serial wire debug I/O                 |
|              | SWCLK    | SWCLK   | Serial wire clock input from ST-LINK  |

The first run didn't seem to have any effect on the nRF52832, but an oscilloscope wasn't available for troubleshooting at the time.
After acquiring an oscilloscope and connecting it to the Glitch-DEC1 wire, it was observed that there was only a small pulse happening on DEC1 at the glitch offset; the short circuit wasn't being applied.
An issue was created on the airtag-glitcher GitHub repo documenting these findings, @GlitchPinNot.
It was established that there was a manufacturing issue with some Debug'n'Dump units, where a pull-down resistor for the Glitch pin was rated at $10k \Omega$ rather than $100 \Omega$, preventing the short circuit from being applied.
This resistor could be removed due to the fact that the Pico pins are internally pulled down; it was redundant.
In the meantime, the approach had changed to use GIAnT, an FPGA-based glitching board and implementation analysis toolkit, to replicate the attack.
Returning to the Debug'n'Dump---after succeeding with GIAnT---and removing its redundant resistor fixed the issue and not only was the short circuit of DEC1 clearly visible on an oscilloscope, but CRP was bypassed within a few minutes.

## Using GIAnT

GIAnT, an implementation analysis toolkit based around an FPGA and created by @oswaldGiantrevBGIAnTFault, was used as the glitch generator for attacking the nRF52832 after experimenting with the Pico Debug'n'Dump.
The GIAnT board used for this experiment didn't originally have a transistor soldered to it (but had the solder pads available) for the purposes of a crowbar circuit, so a MOSFET had to be added to the trace leading to pin T1, along with the capability to use it in the FPGA bytestream.

Wiring the nRF52832 to the GIAnT is similar to the Pico Debug'n'Dump configuration: VDD on the MCU is plugged into the DAC output on the GIAnT and DEC1 is wired to T1 on the GIAnT for the CPU crowbar.

After flashing the firmware to the GIAnT development board, a Python library is used to interact with the board over USB and configure DAC voltage and the glitching parameters: the pin address for triggering the glitch, the glitch offset and the glitch width.

The application, @NRF52832FullGIAnT, configures the GIAnT board to keep shorting the nRF52832's CPU to ground momentarily at an increasing offset and with multiple pulse widths, to increase the likelihood of finding a successful glitch---that is, a glitch causing the bypass of CRP.
The initial offset is configured to be immediately before the critical section (see "Finding a suitable glitch offset").
Once there is a glitch success---defined as the firmware read command being allowed by the MCU---the application on the controlling computer stops running, and a dump of the nRF52832's firmware is left in the working directory.

### Finding a suitable glitch width\label{section_nrf52832_suitable_width}

Although the parameters will change, a suitable minimum glitch width should be found.
This is defined in this case as the smallest glitch width at which a CPU instruction will be skipped or miscalculated.
If the glitch width is too small, there is a chance that it will have no effect (or is too small for the glitch generator), but if it is too large, the microcontroller might reset or the CPU might not start up again.

On each iteration, the glitch width is increased by $10ns$ to increase the likelihood of a successful glitch, should it require a longer glitch width.
The difference between the smallest and largest glitch width is not large, because it could extend runtime unnecessarily, given the fact that the minimum glitch width should already reliably glitch a test application.

This step can also be used to diagnose any problems with the glitching setup because in most cases where the CPU voltage is glitched, a fault should occur in the execution of the running application.
@oflynnFaultInjectionUsing2016 uses a `for` loop containing a counter incrementation, nested in another `for` loop, to show how the counter incrementation is skipped when both loops are complete and the counter is printed.
Due to the added complexity of relying on printing to a buffer---requiring some use of another serial connection in this case---a simple GPIO pin toggling application was used and an oscilloscope was connected to that pin to observe the effect of a glitch, @rudmanNRF52832BlinkPin.
Normal operation of this application is shown in figure \ref{img_nrf52832_blink_no_glitch}.

![The pin toggling application functioning normally, with no glitch. Trace 1 (yellow) is the CPU core voltage and trace 2 (blue) is the pin being toggled by the application. Trigger _T_ points to the moment the nRF52832 becomes powered.\label{img_nrf52832_blink_no_glitch}](res/nrf52832_blink_no_glitch.png){width=400px}

After creating a simple script to try a given glitch width over a rough range of offsets, @rudmanNRF52832MinimumGlitch, the script was run against the nRF52832 running its pin toggling application.
Manually increasing the value of `width` in the script from $10ns$---the GIAnT board cannot produce glitches shorter than $10ns$---showed that the minimum glitch width to successfully fault the CPU execution, at least in the case of application execution, is $50ns$, as shown in figure \ref{img_nrf52832_blink_glitch}.
The result of the fault is that the application jumps out of the `while` loop altogether, even at different offsets.
This could be due to skipping a jump instruction, but it is likely that the fault occurs during the 5ms delay routine---which doesn't just use `NOP`s in the case of the nRF52832---and jumps out of it, especially because the glitch will work at many offsets.
At widths as large as $140ns$, the CPU would permanently fail until the next reset, as shown in figure \ref{img_nrf52832_blink_permafail}.

![The pin toggling application being faulted, with a $50ns$ glitch applied to the CPU core at trigger _T_. Trace 1 (yellow) is the CPU core voltage and trace 2 (blue) is the pin being toggled by the application. Normal operation shown in figure \ref{img_nrf52832_blink_no_glitch}.\label{img_nrf52832_blink_glitch}](res/nrf52832_blink_glitch.png){width=400px}

![The pin toggling application being faulted, with a $140ns$ glitch applied to the CPU core at trigger _T_, causing the CPU to permanently fail until next reset. Trace 1 (yellow) is the CPU core voltage and trace 2 (blue) is the pin being toggled by the application. Normal operation shown in figure \ref{img_nrf52832_blink_no_glitch}.\label{img_nrf52832_blink_permafail}](res/nrf52832_blink_permafail.png){width=400px}

Later investigation has found that a width of $50ns$ is typically too short to reliably fault the NVMC activity and therefore the CRP, and glitch widths as large as $180ns$ do not cause the CPU to permanently fail until reset when targeting the critical section. <!-- Why? -->
This is why it is important to cycle through a number of glitch widths when approaching a critical section.

The widths for 399 successful glitches were recorded and the proportion of glitch successes for each glitch width is shown in figure \ref{img_nrf52832_offset_vs_success}.
A successful glitch is defined as a glitch on the NVMC activity outlined in section \ref{section_nrf52832_suitable_offset} which bypasses CRP and allows the firmware to be dumped.
Figure \ref{img_nrf52832_offset_vs_success} shows that the optimal glitch width is between $80ns$ and $120ns$.
It's important, for future glitch campaigns on the nRF52832 CPU core using a crowbar technique, that the glitch width range used is reduced to this identified range because it can reduce the time needed for a successful glitch.
Although there have been successes outside of the $80-120ns$ range, successful glitches can still be made more likely in the $80-120ns$ range by repeating with the same parameters, which is especially useful at counteracting jitter.

![Glitch width vs. proportion of successes (out of 399 successes) for the nRF52832.\label{img_nrf52832_width_vs_success}](res/nrf52832_width_vs_success.png){width=400px}

### Finding a suitable glitch offset\label{section_nrf52832_suitable_offset}

The glitch offset for the nRF52832 is the amount of time after supplying power to its development board until the glitch is applied.
In practise, this makes it the amount of time until immediately before the start of the critical section to make sure a glitching opportunity isn't missed and to compensate for any jitter (the critical section occurring earlier or later on the next power cycle).

Because this experiment was carried out to replicate work by @limitedresultsNRF52DebugResurrection2020 and @rothHowAppleAirTags2021 and apply a successful glitch, the focus was to find the same critical sections that they have highlighted in their work.
For example, @limitedresultsNRF52DebugResurrection2020 identified the section of non-volatile memory controller (NVMC) activity in figure \ref{img_nrf52832_limitedresults_crit_section}, before the CPU core voltage drops and execution of the application starts.
This NVMC activity, according to @limitedresultsNRF52DebugResurrection2020, is likely to contain the transfer of user information configuration register (UICR) data, including the CRP value APPROTECT, to the CPU core.
A similar section was identified for the nRF52832 and has been highlighted in figure \ref{img_nrf52832_crit_section_no_zoom}, and is shown, zoomed-in, in figure \ref{img_nrf52832_crit_section_zoom}.
The noise present in figures \ref{img_nrf52832_crit_section_no_zoom} and \ref{img_nrf52832_crit_section_zoom} is due to the nRF52832 VDD being connected to the GIAnT DAC, rather than the ST-LINK V2.

![Red box highlighting critical section after nRF52832 power-on. Trace 1 (yellow) is the CPU core voltage, trace 2 (blue) is the voltage of VDD, trace 3 (purple) is the pin being toggled by the application on the nRF52832.\label{img_nrf52832_crit_section_no_zoom}](res/nrf52832_crit_section_no_zoom_highlight.png){width=400px}

![Zoomed-in version of the traces in figure \ref{img_nrf52832_crit_section_no_zoom}. Critical section (NVMC activity) highlighted in red box.\label{img_nrf52832_crit_section_zoom}](res/nrf52832_crit_section_zoom_highlight.png){width=400px}

![Screenshot of the nRF52840 critical section, captured by @limitedresultsNRF52DebugResurrection2020. Trace 2 (light blue) is the CPU core voltage at DEC1 and trace 4 (dark blue) is the system power voltage at DEC4. Compare with figure \ref{img_nrf52832_crit_section_zoom}.\label{img_nrf52832_limitedresults_crit_section}](res/nrf52832_limitedresults_crit_section.png){width=400px}

This critical section lasts for about $2\mu s$, although glitches are usually successful in the later part of the critical section.
To account for jitter---the changing location of the critical section between power cycles---the glitch offset can be said to start at $1029\mu s$ after supplying power to the nRF52832, and increase by $1\mu s$ until $1044\mu s$.
The offsets for 399 successful glitches were recorded and the proportion of glitch successes for each glitch offset is shown in figure \ref{img_nrf52832_offset_vs_success}.

![Glitch offset vs. proportion of successes (out of 399 successes) for the nRF52832.\label{img_nrf52832_offset_vs_success}](res/nrf52832_offset_vs_success.png){width=400px}

## Observations

![A successful glitch on the nRF52832. Trace 1 (yellow) is the CPU core voltage through DEC1 and trace 2 (blue) is the system voltage. Compare this to figure \ref{img_nrf52832_crit_section_zoom}; notice how the CPU core voltage doesn't drop after the glitch.\label{img_nrf52832_successful}](res/nrf52832_successful.png){width=400px}

<!-- TODO (HOME): Is it really a "pure hardware process" as LimitedResults says? It looks like on a successful glitch, the whole low section is skipped. -->
<!-- TODO: Conclude the nRF52832 section -->

# CC2541 glitch attempts

The CC2541 microcontroller sits within Texas Instruments' CC253x/4x line-up of SoCs, which are all based on a modified 8051 microcontroller, differing from the nRF52832 which uses an ARM Cortex-M4.
The main difference between the CC253x and CC254x series is that CC253x SoCs are intended for applications which implement IEEE 802.15.4-based protocols and the CC254x series is intended for bluetooth low-energy applications.
As previously stated, the CC2541 is based around a different processor than the nRF52832, but the two chips are similar in that they don't contain boot ROM; there's no read-only bootloader by default on either of the devices.
This means that, for a crowbar glitch applied to the CPU to be successful, there needs to be some handling of the CRP data by the CPU.

There were three lessons learned during the nRF52832 glitch attempts, which informed the exploratory glitch campaign on the CC2541:

- When looking for a suitable glitch offset, use an oscilloscope from the beginning; study the power traces for notable features when using the SoC for various activities, especially immediately after reset and power-on. This is known generally as simple power analysis (SPA).
- Read the data sheet and user guide more thoroughly before attempting a voltage glitch, especially for information about bootloaders, which have logic commonly executed by the CPU and as a result can be glitched using the crowbar technique on the CPU decoupling circuit.
- Use the debugging interface to get used to reading the flash contents from the target and define a benchmark against which to check whether CRP is still enabled.

These learning outcomes encouraged a deeper analysis of how the SoC or microcontroller functions _before_ leaving the glitch generator running to brute-force search the glitch parameter space.

## Modifications

The CC2541 is similar to the nRF52832 in that it also has a digital supply decoupling pin, DCOUPL, for use with a decoupling capacitor.
Decoupling capacitors are intended to smooth out any sudden changes in voltage, so it's important that the decoupling capacitors are removed in order to see useful voltage traces when using an oscilloscope, and because they might prevent a successful voltage glitch. <!-- TODO: Add comparison screenshots from recordings -->
Initially the removal of the capacitor connected to DCOUPL was neglected and the voltage trace on DCOUPL looked very featureless; voltage trace readings were repeated after removing it.

For easy connection to jumper wires and oscilloscope probes, wires were connected to the following areas on the CC2541 development board:

- VDD: Power supply---there was already a header pin for this
- GND: Ground---there was already a header pin for this
- DD: Debug data pin, for debugging
- DC: Debug clock pin, for debugging
- RESET_N: Reset pin, for debugging
- DCOUPL: $1.8V$ digital supply decoupling circuit

For all pins other than VDD and GND, a solder pad on the development board was used to reduce mechanical strain on the chip legs, requiring continuity testing between legs and pads.
DCOUPL was only one decoupling circuit listed in the data sheet, so it was assumed that if a successful crowbar voltage glitch would be possible, it would be on DCOUPL due to the lack of alternatives.

## Wiring

After soldering work to attach jumper wires, the following connections were made between the GIAnT board, the CC2541 development board and the CC Debugger.
The CC Debugger is required for debugging and flashing, due to the lack of bootloader and reliance on proprietary debugging circuits.
It can be seen as taking the place of the ST-LINK V2 from the nRF52832 glitch campaign.

| GIAnT        | CC2541   | CC Debugger | Description                           |
|--------------|----------|-------------|---------------------------------------|
| DAC out      | VDD      | SENSE       | Supplies CC2541 with $3.3V$ and the CC Debugger senses it |
| T1           | DCOUPL   |             | Applies the glitch                    |
| GND          | GND      | GND         | Grounds the CC2541                    |
|              | DD       | DD          | Debug data connection                 |
|              | DC       | DC          | Debug clock connection                |
| GPIO1_6      | RESET_N  | RST         | Allows the CC Debugger to reset CC2541 and GIAnT to sense it |

Initially, the CC2541 was powered exclusively by the CC Debugger, with DCOUPL and RESET_N being connected to the GIAnT from the CC2541.
This was done so the CC Debugger could have full control over the CC2541, while allowing GIAnT to trigger when RESET_N was pulled high.
After unsuccessful glitch attempts during and after reset it became apparent that it would be impossible, in this configuration, to apply a glitch after powering on the CC2541---like the nRF52832 attack---because VDD would always remain high if powered by the CC Debugger.
The finalised configuration in the table above allows the GIAnT to power up or down the CC2541, while allowing the CC Debugger to reset the CC2541.
Even though power is supplied by the GIAnT DAC, the CC Debugger still needs to be connected with the SENSE pin---used when power is supplied to the target by another device---in order to preserve debugging functionality.
When the target is being supplied with power by another device, the power supply on the CC Debugger breakout board must be turned off.

Preserving debugging functionality required the following connections to be present for the CC Debugger:

- VDD or SENSE
- GND
- DD
- DC
- RST

As long as SENSE is high (i.e. GIAnT DAC is supplying power to CC2541) when the CC Debugger is first manually reset with its reset button and is high when CC Debugger next communicates with the CC2541, the CC Debugger will correctly interface with the CC2541.

## Glitch experiments plan

For the CC2541, the CRP data is stored as a "debug lock bit": bit 127 (zero-indexed) in the "upper available flash page", according to the user guide. <!-- TODO: Reference User Guide -->
The following experiments will be attempted:

1. Try to glitch a simple application while it's running on the CC2541 to find suitable parameters.
2. Use simple power analysis (SPA) to look for potential critical sections---areas where a voltage glitch might cause a CRP bypass.
3. Attempt to glitch the potential critical sections using parameters found in experiment 1.
4. If experiment 3 is unsuccessful, apply differential power analysis (DPA) to look for more definitive critical sections to glitch.

Differential power analysis has been placed last in the list of experiments due to its time-consuming nature; thousands of traces need to be recorded from the oscilloscope, which also must be interfaced with the general purpose computer.

<!-- TODO: Describe setup with cc-tool, incl. --log and other commands -->

## Finding a suitable glitch width

The reasoning behind finding a suitable minimum glitch width is outlined in section \ref{section_nrf52832_suitable_width}.
Much like the code written for finding the minimum glitch width for the nRF52832, a test application was written to toggle a pin on the CC2541 at $5ms$ intervals @rudmanCC2541BlinkPin, and a script was created for using the GIAnT board to glitch the CC2541 at an increasing offset @rudmanCC2541MinimumGlitch.
The pin toggling application is configured to toggle pin 0.2 on the CC2541, which is connected to a header pin on its development board labelled "state".
The first two pin toggles are only $1ms$ apart to show more clearly when the application starts.
Normal operation of the pin toggling application is shown in figure \ref{img_cc2541_blink_no_glitch}.

![
The CC2541 pin toggling application without a glitch. Trace 1 (yellow): DCOUPL, trace 2 (light blue): RESET_N, trace 3 (purple): STATE on the development board (the pin being toggled), trace 4 (dark blue): Debug Data.
\label{img_cc2541_blink_no_glitch}
](res/cc2541_blink_no_glitch.png){width=400px}

Due to the use of `NOP`s in the `delay_ms` function written by Grapsus @grapsusCc254xSdcc for the CC2541 and used by the application, most offsets will not show a discernible glitch outcome, unlike for the nRF52832.
This means that, unless the glitch occurs within a single clock cycle, or about $31ns$, before the "state" pin toggles, the trace will continue to look like the application is running as expected, because only a `NOP` or two are skipped.
The most that will happen is that the next pin toggle may come a couple of cycles sooner, which isn't very visible.
Glitching within a cycle or two before the "state" pin toggles does however show a successful glitch in the application, seen in figure \ref{img_cc2541_blink_glitch}.
The smallest glitch width for a successful glitch to the pin toggling application was $50ns$.
$80ns$ is the maximum glitch width before the microcontroller resets, as seen in figure \ref{img_cc2541_blink_reset}, where a $90ns$ width was used.
The initialisation pattern is visible in trace 1 (DCOUPL) in figure \ref{img_cc2541_blink_reset} and figure \ref{img_cc2541_blink_no_glitch}, which shows the same pattern when powered on.

The reason there are no success rates listed is because the success of each glitch can't easily be determined for the test application (pin toggling) and there was no success with a CRP bypass to be measured.

![
The CC2541 pin toggling application with a $50ns$ crowbar glitch at trigger _T_, causing the pin toggle instruction to be skipped and the STATE pin remains high for another $5ms$.
Trace 1 (yellow): DCOUPL, trace 2 (light blue): RESET_N, trace 3 (purple): STATE on the development board (the pin being toggled).
\label{img_cc2541_blink_glitch}
](res/cc2541_blink_glitch.png){width=400px}

![
The CC2541 pin toggling application with a $90ns$ crowbar glitch at trigger _T_, causing a reset, visible in the pattern in trace 1 and the initial $1ms$ pin toggle in trace 3, at the start of the application.
Trace 1 (yellow): DCOUPL, trace 2 (light blue): RESET_N, trace 3 (purple): STATE on the development board (the pin being toggled), trace 4 (dark blue): Debug Data.
\label{img_cc2541_blink_reset}
](res/cc2541_blink_reset.png){width=400px}

## Finding a suitable glitch offset\label{section_cc2541_suitable_offset}

Generally speaking, potential critical sections for bypassing CRP are found before the application starts running.
This is because, even without boot ROM, any CRP check or movement of CRP data to the CPU is an initialisation step, which would need to occur before normal CPU execution and potential debug connection.

In order to identify these potential critical sections and infer more about how the CC2541 works, an oscilloscope was connected to measure the voltages of DCOUPL, VDD, RESET_N and the state pin used by the pin toggling application.
The voltage traces should be analysed during the most likely areas in which a CRP check might exist:

- powering on the CC2541 (cold boot, figure \ref{img_cc2541_blink_no_glitch}) or after reset;
- debugging communication using `cc-tool` from the general purpose computer with the CC Debugger (figure \ref{img_cc2541_debugging}).

![
Using `cc-tool` to read basic info about the CC2541: what its debug status is and its name and flags.
Trace 1 (yellow): DCOUPL, trace 2 (light blue): RESET_N, trace 3 (purple): STATE on the development board (the pin being toggled), trace 4 (dark blue): Debug Data.
\label{img_cc2541_debugging}
](res/cc2541_basic_info_debug.png){width=400px}

In figure \ref{img_cc2541_debugging}, it can be seen that before and after every debugging command is sent to the CC2541 by the CC Debugger, RESET_N is held low while two falling edge transitions are forced on Debug Clock.
It can be assumed that after every reset out of debug mode, the CC2541 MCU reinitialises and CRP data is moved from flash again, if it is read by the CPU at all.
This is a fair assumption because setting the debug lock with `cc-tool --lock debug` enables CRP for all subsequent debug commands, as seen below.

```
$ cc-tool -r out.bin
  Programmer: CC Debugger
  Target: CC2540
  Target is locked.
  No operations allowed on locked target without erasing
```

In order to check whether a glitch has been successful at bypassing CRP, a non-error response from `cc-tool` which does not contain "Target is locked" is used as the benchmark in the GIAnT scripts [@rudmanCC2541CommandTriggeredGlitch; @rudmanCC2541ColdBoot].
Unless the area of memory containing the debug lock bit is permanently changed---something not likely with a crowbar glitch on the CPU---any outcome from a glitch before `cc-tool` is used will be reverted by the reset before each debug command, which includes the check to see whether the glitch has been successful.
Therefore any glitch on a cold boot is unlikely to bypass CRP in a meaningful way, because checking the debug lock bit will reset the chip and re-enable the CRP.

The result of this is that the best chance of a successful glitch on CRP is during the time from the reset before the debug command is sent to the CC2541, until the debug command is processed by the CC2541.
This is the period of time between trigger _T_ on figure \ref{img_cc2541_debugging} and $8ms$ later.

## Glitch attempts

Before carrying out differential power analysis (DPA), glitch attempts were made across the offset space outlined in section \ref{section_cc2541_suitable_offset}, cold boot and during and immediately after a debugging-triggered reset.
Glitch attempts were made using GIAnT interface scripts on both reset during debugging command execution @rudmanCC2541CommandTriggeredGlitch and cold boot @rudmanCC2541ColdBoot.
Glitching on a cold boot and not during the reset and debug communication was never likely to produce a CRP bypass, as described in section \ref{section_cc2541_suitable_offset}, but was carried out as a fallback after glitching during debug communication didn't produce a CRP bypass.
<!-- TODO: Reference glitcher code for resets and note the parameters -->
<!-- TODO: Reference glitcher code for cold boot and note the parameters -->

### Outcome: Corrupted debug status

For all of the offsets at which a glitch was applied, no CRP bypass was achieved.
There were two times at which the microcontroller didn't reset and there was no "Target is locked" message, but neither of these were a CRP bypass.

The first time time there was no "Target is locked" message was when the glitch was applied during debug communications; the `cc-tool` logs show that glitches during debug communications often cause the response or the processing of a request to be corrupted.
Notice, in the log message in appendix \ref{appendix_corrupted_debug_status}, the following lines:

```
[21.02 13:29:34:99695] programmer, debug status, 00h
[21.02 13:29:34:99695] programmer, halt failed
```

See how the debug status returned is `00h` and not `26h` (CRP enabled) or `22h` (CRP disabled).
When glitching around the time of this USB read, the value sent back to the CC Debugger can be corrupted and be any other value.
This isn't helpful, because even if it is corrupted to `22h`, that doesn't mean that CRP has actually been disabled for subsequent flash reads, only that the message has been corrupted.


### Outcome: Erased flash

<!-- TODO: Talk about the glitch that erases the flash -->

![
The CC2541 glitch during debug communication which was initially thought to be successful; CRP was only disabled at the expense of erasing the flash, which defeats the purpose of the attack.
Notice how trace 3 doesn't start toggling again because the application has been wiped.
Trace 1 (yellow): DCOUPL, trace 2 (light blue): RESET_N, trace 3 (purple): STATE on the development board (the pin being toggled), trace 4 (dark blue): Debug Data.
\label{img_cc2541_glitch_success}
](res/cc2541_glitch_success.png){width=500px}

<!-- TODO: Talk about no-reset cc-tool and why it doesn't work. Resetting not optional; the reset with two falling edges is required to put into debug mode. -->

## Differential power analysis

<!-- TODO: Define DPA -->
<!-- TODO: Add a section on interfacing with the oscilloscope -->
<!-- TODO: Show results of DPA, why they don't really help -->
<!-- TODO: Maybe don't even do this section, or just do a best efforts thing -->

## Observations

<!-- TODO: Doesn't have an embedded bootloader, but neither does the nRF52832, so why does this mean the crowbar glitch isn't possible? -->
<!-- TODO: Maybe one reason for the more featureless traces is because DCOUPL is for the whole MCU and not the CPU? -->
<!-- TODO: Things I wish I had done or known, to speed up the process: boot rom stuff and forgetting to remove the capacitor -->

## Areas of difficulty

## Future work

If there were more time for this project, it would have extended to include the following work:

- Using a faster oscilloscope to collect more traces in order to produce more accurate DPA results on the CC2541.
- Building on the knowledge gained about how the CC2541 works to attempt to glitch VDD on the CC2541, undervolting or overvolting---not using a crowbar attack---to set the debug lock bit.
- Checking whether the CC2541 has the same vulnerability where the RAM isn't erased with the flash, as demonstrated by Goodspeed for the CC2430 @goodspeedExtractingKeysSecond.
- Improving the ease of use of voltage glitching by refactoring GIAnT into a Python package and adding to the currently sparse documentation.

# Evaluation

## Comparing outcomes to success criteria

The crowbar attack on nRF52 microcontrollers shown by LimitedResults @limitedresultsNRF52DebugResurrection2020 and Roth @rothHowAppleAirTags2021 was successfully repeated for the nRF52832 on a cheaply available development board using both the Pico Debug'n'Dump and GIAnT.

This project has shown that neither the CC2541, nor the family of SoCs of which it is a member, are susceptible to crowbar voltage glitches to bypass CRP without erasing the flash memory.
In addition, I have learned many new skills throughout:

- Using an oscilloscope for both simple power analysis and voltage trace extraction over USB.
- Deeper understanding of how SoCs and microcontrollers work and their architectures, especially for the nRF52 and CC253x/4x product families.
- Practical experience of voltage glitching using FPGA-based solutions and less real-time microcontroller-based solutions.
- Using all of the software tooling required for the above devices.

Methods for making crowbar attacks and other voltage glitches easier have also been outlined. <!-- TODO: No they haven't, do this -->


<!-- TODO: Write section. Use below as a template -->

What I'd have done differently.
For some things, it's hard to say, because I've learned a lot for the first time in this project.
Knowing what I know now, it would have been better to identify whether there was any bootloader code I could have targeted before blindly glitching potential critical sections (although this glitching didn't take long).
I would also have attempted DPA earlier on, but I did not know what the knowledge barriers for communicating with the oscilloscope would be, so it could have really slowed down the project if I had.

## Conclusion

<!-- TODO: Write conclusion. Use below as a template -->

I believe the crowbar glitch is not possible on the CC2541 because there does not seem to be a firmware bootloader in protected memory that can be affected by glitching the CPU.

During this project, I've found that voltage glitching has been made more accessible with the Pico Debug‘n’Dump, due to the low cost and ease of use.
If the resistor was the correct spec, I’d have managed to glitch the nRF52832 with far less troubleshooting, probably within a few days, or even under an hour, with a basic setup guide and more comprehensive pin descriptions.
The GIAnT, on the other hand, is a much more complex and versatile device, which gives it a lot of value when it comes to discovering which type of glitch will work best for a microcontroller, but not ease of use.

If you know that you'll be glitching the bootloader, can use a CPU crowbar and don't need very precise timings, the Debug'n'Dump is a less expensive, easier option.

# References

\vspace{0.5cm}

<div id="refs"></div>

\appendix

# `cc-tool` logs

## Corrupted debug status\label{appendix_corrupted_debug_status}

```
Command '['cc-tool', '-i', '--log']' returned non-zero exit status 1.
[21.02 13:29:34:99664] main, cc-tool 0.26
[21.02 13:29:34:99664] main, command line: cc-tool -i --log 
[21.02 13:29:34:99672] usb, open device, VID: 0451h, PID: 16A2h
[21.02 13:29:34:99672] usb, set configuration 1
[21.02 13:29:34:99680] usb, claim interface 0
[21.02 13:29:34:99682] usb, get string descriptor 2, data: CC Debugger
[21.02 13:29:34:99682] programmer, request device state
[21.02 13:29:34:99682] usb, control read, request_type: C0h, request: C0h, value: 0000h, index: 0000h, count: 8
[21.02 13:29:34:99682] usb, control read, data: 40 25 CC 05 44 00 01 00
[21.02 13:29:34:99682] device, name: CC Debugger, ID: 0100, version: 05CCh, revision: 0044h
[21.02 13:29:34:99682] programmer, set debug interface speed 0
[21.02 13:29:34:99682] usb, control write, request_type: 40h, request: CFh, value: 0001h, index: 0000h, count: 0
[21.02 13:29:34:99682] programmer, connect target
[21.02 13:29:34:99682] programmer, enter debug mode
[21.02 13:29:34:99682] usb, control write, request_type: 40h, request: C5h, value: 0000h, index: 0000h, count: 0
[21.02 13:29:34:99683] usb, control write, request_type: 40h, request: C8h, value: 0001h, index: 0000h, count: 48
[21.02 13:29:34:99683] usb, control write, data: 43 43 32 35 34 30 20 20 20 20 20 20 20 20 20 20 44 49 44 3A 20 30 31 30 30 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20
[21.02 13:29:34:99684] programmer, reset target, debug mode: 1
[21.02 13:29:34:99684] usb, control write, request_type: 40h, request: C9h, value: 0000h, index: 0001h, count: 0
[21.02 13:29:34:99694] programmer, read debug status
[21.02 13:29:34:99694] usb, bulk write, count: 2, data: 1F 34
[21.02 13:29:34:99695] usb, bulk read, count 1: data: 00
[21.02 13:29:34:99695] programmer, debug status, 00h
[21.02 13:29:34:99695] programmer, halt failed
```
